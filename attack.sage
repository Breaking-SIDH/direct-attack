#!/usr/bin/env sage

# Python imports
import time

# Local imports
from generate_public_values import *
from attack_aux import an_isogeny, divide_by, find_secret_key
from richelot_aux import Does22ChainSplit

# Load speed up for SageMath versions <= 9.6
load('speedup.sage')

#----------------------------------------------------------------------
# Parameter selection for the attack. Currently, we have attacks
# which target either
#   - [toy]  : A 34-bit prime p = 3^9 * 2^19 - 1
#   - [baby] : A 64-bit prime p = 3^19 * 2^33 - 1
#              Used as a small example in https://ia.cr/2022/1283
#
# Parameter set includes:
#   - ea, eb such that p = 3^ea * 2^eb - 1
#   - e,i,j,f such that eB' = f + A'.
#----------------------------------------------------------------------

parameter_sets = {
    "toy" : {
        "ea" : 9,
        "eb" : 19,
        "e"  : 2,
        "i"  : 1,
        "j"  : 0,
        "f"  : 5 * 13 * 17 * 23 * 41
    },
    "baby" : {
        "ea" : 19,
        "eb" : 33,
        "e"  : 1,
        "i"  : 3,
        "j"  : 5,
        "f"  : 5 * 11 * 13 * 19 * 47 * 353
    }
}

instances = parameter_sets.keys()
if len(sys.argv) > 1:
    if sys.argv[1] in instances:
        instance = sys.argv[1]
    else:
        print(f'\x1b[31mbad instance name\x1b[0m {sys.argv[1]!r}\x1b[0m (must be one of {instances})', file=sys.stderr)
        exit(1)
else:
    instance = 'toy'

# Set the attack parameters from the current instance
params = parameter_sets[instance]

# Construct the characteristic p = la^ea * lb^eb - 1
# and the starting supersingular curve E0 / Fp2
ea, eb = params["ea"], params["eb"]
la, lb = 3, 2
A, B = la^ea, lb^eb
p = A*B - 1
Fp2.<i> = GF(p^2, modulus=[1,0,1])

E0 = EllipticCurve(Fp2, [0,6,0,1,0])
E0.set_order((p+1)^2, num_checks=0)


#----------------------------------------------------------------------
# Step 0: Create a challenge with toy parameters and mask the
#         endomorphism ring of the starting curve.
#----------------------------------------------------------------------
time_setup = time.time()

# Starting from a random curve
rndcrv  = randint(0,200)
for _ in range(rndcrv):
    xs = E0.two_division_polynomial().roots(multiplicities=False)
    E0 = E0.isogeny(E0.lift_x(choice(xs))).codomain()
E0.set_order((p+1)^2, num_checks=0)

# Generating public torsion points
PA, QA, PB, QB = generate_torsion_points(E0, la, ea, lb, eb)
assert check_torsion_points(E0, la, ea, lb, eb, PA, QA, PB, QB)

print("----------------------------------------------------------------------")
print("The starting curve is")
print(E0)
print("----------------------------------------------------------------------")
print(f"The 3^{ea}-torsion group is generated by")
print(PA)
print(QA)
print("----------------------------------------------------------------------")
print(f"The 2^{eb}-torsion group is generated by")
print(PB)
print(QB)
print("----------------------------------------------------------------------")

# Generate Alice's key pair
alice_private, (EA, phiPB, phiQB) = gen_keypair(E0, PA, QA, PB, QB, la, ea)

print("The public key is")
print(EA)
print(phiPB)
print(phiQB)
print("----------------------------------------------------------------------")
print(f"If successful, the attack will recover the secret: {alice_private}")
print("----------------------------------------------------------------------")
print("Generating the public parameters for the attack required {:.2f}s".format(time.time() - time_setup))
print("----------------------------------------------------------------------")


#----------------------------------------------------------------------
# Step 1: Compute integers such that eB' = f + A'.
#         This has been precomputed for these toy examples.
#----------------------------------------------------------------------

# First extract the integers (e,i,j,f)
# from the precomputed parameter set
the_e = params["e"]
the_i = params["i"]
the_j = params["j"]
the_f = params["f"]

# Precompute factors:
factors_f = ecm.factor(the_f)

A_prime = A // (la^the_i)
B_prime = B // (lb^the_j)
# We compute a chain of length eB'.
# We assume e is a power of two
chain_length = log(the_e*B_prime, 2)

assert the_e * B_prime == the_f + A_prime
the_c = inverse_mod(A_prime, the_e * B_prime)

E_temp = E0
PB_temp = PB
QB_temp = QB

#----------------------------------------------------------------------
# Step 2: Compute a curve f-isogenous to E0.
#         Here, we compute a chain of isogenies for each factor of
#         f, the degree of the cofactor isogeny.
#
#         Each isogeny in the chain is computed by finding the minimal
#         extension E / Fp^k such that there is a point of order q.
#         This point is used to generate a kernel polynomial from which
#         we obtain an isogeny to a new curve in E/Fp2.
#----------------------------------------------------------------------
tin = time.time()
for q in factors_f:
    print(f"Computing cofactor isogeny for prime factor: {q = }")
    phi_temp = an_isogeny(E_temp, q)
    PB_temp = phi_temp(E_temp(PB_temp))
    QB_temp = phi_temp(E_temp(QB_temp))
    E_temp = phi_temp.codomain()
    E_temp.set_order((p+1)**2, num_checks=0)

tfin = time.time()
print("Computing the dual of the cofactor isogeny required %0.2fs" % (tfin - tin))
print("----------------------------------------------------------------------")

# E is the domain of the f-isogeny varphi_f : E -> E0
# PB_E denotes \hat{varphi}_f(PB)
# Similarly for QB_E
E = E_temp
E.set_order((p+1)^2, num_checks=0)

PB_E = PB_temp
QB_E = QB_temp

#----------------------------------------------------------------------
# Step 3: Compute a basis P_{eB'}, Q_{eB'} of E[eB']
#         To do this, we find the minimal extension degree `deg`,
#         following this, we compute the basis.
#
#         We have [e]P_{eB'} = [l_B^j] \hat{varphi} (P_B) and
#                 [e]Q_{eB'} = [l_B^j] \hat{varphi} (Q_B)
#         which are found from (1/e) [l_B^j] \hat{varphi} (X_B).
#         To perform this division, we need to go to an extension
#         E_ext.
#----------------------------------------------------------------------

# extending the base field to find points dividing PB_E and QB_E
deg = min(i for i,n in enumerate(E.count_points(the_e+1),1) if (the_e*B_prime).divides(sqrt(n)))

print(f"DEBUG: Computed the degree: {deg}")

Fq = Fp2.extension(deg, name="T") # add a name to stop slow Conway polynomial
print(f"DEBUG: Computed extension field")
E_ext = E.base_extend(Fq)
print(f"DEBUG: Extended the curve's field by the extension")

# Computing points on the extension curve so we can divide by e
P_eBprime = next(divide_by(E_ext(lb^the_j * PB_E), the_e))
Q_eBprime = next(divide_by(E_ext(lb^the_j * QB_E), the_e))

# Short hand for Weil pairing of fixed degree eB'
pair = lambda P,Q: P.weil_pairing(Q, the_e*B_prime)

#----------------------------------------------------------------------
# Step 4: Make a guess \phi_{\ell_A^i}.
#         This requires first guessing the isogeny, computing the basis
#         R,S. As this requires dividing by e, there is a list of all
#         possible values, so the higher e, the more guesses that will
#         need to be made for each isogeny guess.
#----------------------------------------------------------------------
#----------------------------------------------------------------------
# Step 5: Test the guess \phi_{\ell_A^i}.
#         In our code, we combin steps 4,5. Once we have our guess
#         \phi_{\ell_A^i} with the basis R,S of E'[eB'] then we test
#         the correctness of the guess with the oracle `Does22ChainSplit`.
#         This computes an (eB', eB')-isogeny with domain E x E'. If the
#         codomain of this isogeny splits as a product of elliptic curves
#         the guess is correct.
#----------------------------------------------------------------------
def guess_last_steps_dual(Et,i):
    P,Q = (R.element() for R in Et.abelian_group().torsion_subgroup(la^i).gens())
    vs = [(1,y) for y in range(la^i)] + [(x,1) for x in range(0,la^i,la)]
    for v in vs:
        yield Et.isogeny(v[0]*P + v[1]*Q, algorithm='factored')

def guess_isogeny():
    inv_la_the_i = inverse_mod(la^the_i, B_prime)
    pair_P_eBprime_Q_eBprime = pair(P_eBprime, Q_eBprime)
    for isogenia in guess_last_steps_dual(EA,the_i):
        print(f"Guessing the last i={the_i} step(s)")
        E_prime = isogenia.codomain()
        dual_phi_ellA_i_phiPB = isogenia(phiPB)
        dual_phi_ellA_i_phiQB = isogenia(phiQB)
        E_prime_ext = E_prime.base_extend(Fq)
        dual_phi_ellA_i_phiPB = E_prime_ext(dual_phi_ellA_i_phiPB)
        dual_phi_ellA_i_phiQB = E_prime_ext(dual_phi_ellA_i_phiQB)

        # step 4 requires multiplication by
        # \ell_A^{-i} * f * \ell_B^{j}
        step_4_scalar = inv_la_the_i*the_f*lb**the_j
        list_R = list(divide_by(step_4_scalar * dual_phi_ellA_i_phiPB, the_e))
        list_S = list(divide_by(step_4_scalar * dual_phi_ellA_i_phiQB, the_e))
        print(f"Trying options for eBlb^(-j)-torsion points")
        filter_points = []
        for R in list_R:
            for S in list_S:
                if pair_P_eBprime_Q_eBprime * pair(R, S)^(the_c^2) == 1:
                        filter_points.append((R,S))
        print(f"Need to check: {len(filter_points)} pairs of points")
        for i, (R,S) in enumerate(filter_points):
            print(f"Guess {i}", end="")
            chain, codomain = Does22ChainSplit(E_ext, E_prime_ext, P_eBprime, Q_eBprime, the_c*R, the_c*S, chain_length)
            if codomain is not None:
                print(f"\r", end="")
                print("----------------------------------------------------------------------")
                return chain, codomain, isogenia, R, S
            print(f"\r", end="")
        print("----------------------------------------------------------------------")
    print(f"Something is broken... Exiting...")
    exit()

t_guess = time.time()
chain, codomain, isogenia, R, S = guess_isogeny()
print("Guessing the correct isogeny required %0.2fs" % (time.time() - t_guess))

#----------------------------------------------------------------------
# Step 6: Compute the basis P,Q of E'[A'] and the image of these points
#         \hat{\phi}'(P), \hat{\phi}'(Q).
#
#         This is accomplished by mapping points through the previously
#         computed (eB', eB')-isogeny chain.
#----------------------------------------------------------------------
# Checking if the isomorphism swapped the curves in the codomain
if codomain[0].j_invariant() == E0.j_invariant():
    index = 0
else:
    index = 1

E0t = codomain[index]

# computing the dual of the first a-i steps
E_prime = isogenia.codomain()
E_prime_ext = E_prime.base_extend(Fq)
PAA, QAA = ( ((p+1) // (la^ea))*G for G in EA.gens())
PAA_E_prime = isogenia(PAA)
QAA_E_prime = isogenia(QAA)
PAA_E_prime = E_prime_ext(PAA_E_prime)
QAA_E_prime = E_prime_ext(QAA_E_prime)

# Map the points using the computed isogeny chain
imPAA = (E_ext(0), PAA_E_prime)
imQAA = (E_ext(0), QAA_E_prime)
for f in chain:
    imPAA = f(imPAA)
    imQAA = f(imQAA)


print("----------------------------------------------------------------------")
E0_ext = E0.change_ring(Fq)
# we have computed the dual up to isomorphisms
psi_list = E0t.isomorphisms(E0_ext)

#----------------------------------------------------------------------
# Step 7: Compute the kernel of \phi'. From this and the correct guess
#         of \phi_{\ell_A^i}, we recover the kernel of Alice's secret
#         isogeny.
#
#         The secret key `x`, from K_A = P + xQ can be recovered by
#         using Weil pairings and solving the discrete logarithm
#         which is efficent as the degree of the isogeny is smooth.
#----------------------------------------------------------------------

# Finding the kernel generator of the first a-i steps
if (3^(ea-1))*imPAA[index] != imPAA[index].curve()(0):
    K = imPAA[index]
else:
    K = imQAA[index]

for psi in psi_list:
    K = E0(psi(K))
    recovered_key = find_secret_key(K, PA, QA, ea)
    recovered_isogeny = E0.isogeny(K, algorithm="factored")
    recovered_curve = recovered_isogeny.codomain()
    if recovered_curve == EA:
        print(f"Secret key recovered: {recovered_key}")
        print(f"The attack is successful: {recovered_key == alice_private}")
        break
print("----------------------------------------------------------------------")
print("Altogether, the attack required {:.2f}s".format(time.time() - tin))
